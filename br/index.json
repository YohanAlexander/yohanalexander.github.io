[{"categories":null,"contents":" Hello World A sample go program is show here.\npackage main import \u0026#34;fmt\u0026#34; func main() { message := greetMe(\u0026#34;world\u0026#34;) fmt.Println(message) } func greetMe(name string) string { return \u0026#34;Hello, \u0026#34; + name + \u0026#34;!\u0026#34; } Run the program as below:\n$ go run hello.go Variables Normal Declaration:\nvar msg string msg = \u0026#34;Hello\u0026#34; Shortcut:\nmsg := \u0026#34;Hello\u0026#34; Constants const Phi = 1.618 ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://yohanalexander.github.io/br/notes/go/basic/introduction/","summary":" Hello World A sample go program is show here.\npackage main import \u0026#34;fmt\u0026#34; func main() { message := greetMe(\u0026#34;world\u0026#34;) fmt.Println(message) } func greetMe(name string) string { return \u0026#34;Hello, \u0026#34; + name + \u0026#34;!\u0026#34; } Run the program as below:\n$ go run hello.go Variables Normal Declaration:\nvar msg string msg = \u0026#34;Hello\u0026#34; Shortcut:\nmsg := \u0026#34;Hello\u0026#34; Constants const Phi = 1.618 ","tags":null,"title":"Go পরিচিতি"},{"categories":null,"contents":" Strings str := \u0026#34;Hello\u0026#34; Multiline string\nstr := `Multiline string` Numbers Typical types\nnum := 3 // int num := 3. // float64 num := 3 + 4i // complex128 num := byte(\u0026#39;a\u0026#39;) // byte (alias for uint8) Other Types\nvar u uint = 7 // uint (unsigned) var p float32 = 22.7 // 32-bit float Arrays // var numbers [5]int numbers := [...]int{0, 0, 0, 0, 0} Pointers func main () { b := *getPointer() fmt.Println(\u0026#34;Value is\u0026#34;, b) func getPointer () (myPointer *int) { a := 234 return \u0026amp;a a := new(int) *a = 234 Pointers point to a memory location of a variable. Go is fully garbage-collected.\nType Conversion i := 2 f := float64(i) u := uint(i) Slice slice := []int{2, 3, 4} slice := []byte(\u0026#34;Hello\u0026#34;) ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://yohanalexander.github.io/br/notes/go/basic/types/","summary":"Strings str := \u0026#34;Hello\u0026#34; Multiline string\nstr := `Multiline string` Numbers Typical types\nnum := 3 // int num := 3. // float64 num := 3 + 4i // complex128 num := byte(\u0026#39;a\u0026#39;) // byte (alias for uint8) Other Types\nvar u uint = 7 // uint (unsigned) var p float32 = 22.7 // 32-bit float Arrays // var numbers [5]int numbers := [...]int{0, 0, 0, 0, 0} Pointers func main () { b := *getPointer() fmt.","tags":null,"title":"বেসিক টাইপ সমূহ"},{"categories":null,"contents":" Condition if day == \u0026#34;sunday\u0026#34; || day == \u0026#34;saturday\u0026#34; { rest() } else if day == \u0026#34;monday\u0026#34; \u0026amp;\u0026amp; isTired() { groan() } else { work() } if _, err := doThing(); err != nil { fmt.Println(\u0026#34;Uh oh\u0026#34;) Switch switch day { case \u0026#34;sunday\u0026#34;: // cases don\u0026#39;t \u0026#34;fall through\u0026#34; by default! fallthrough case \u0026#34;saturday\u0026#34;: rest() default: work() } Loop for count := 0; count \u0026lt;= 10; count++ { fmt.Println(\u0026#34;My counter is at\u0026#34;, count) } entry := []string{\u0026#34;Jack\u0026#34;,\u0026#34;John\u0026#34;,\u0026#34;Jones\u0026#34;} for i, val := range entry { fmt.Printf(\u0026#34;At position %d, the character %s is present\\n\u0026#34;, i, val) n := 0 x := 42 for n != x { n := guess() } ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://yohanalexander.github.io/br/notes/go/basic/flow-control/","summary":"Condition if day == \u0026#34;sunday\u0026#34; || day == \u0026#34;saturday\u0026#34; { rest() } else if day == \u0026#34;monday\u0026#34; \u0026amp;\u0026amp; isTired() { groan() } else { work() } if _, err := doThing(); err != nil { fmt.Println(\u0026#34;Uh oh\u0026#34;) Switch switch day { case \u0026#34;sunday\u0026#34;: // cases don\u0026#39;t \u0026#34;fall through\u0026#34; by default! fallthrough case \u0026#34;saturday\u0026#34;: rest() default: work() } Loop for count := 0; count \u0026lt;= 10; count++ { fmt.Println(\u0026#34;My counter is at\u0026#34;, count) } entry := []string{\u0026#34;Jack\u0026#34;,\u0026#34;John\u0026#34;,\u0026#34;Jones\u0026#34;} for i, val := range entry { fmt.","tags":null,"title":"ফ্লো কন্ট্রোল"},{"categories":null,"contents":" Condition if day == \u0026#34;sunday\u0026#34; || day == \u0026#34;saturday\u0026#34; { rest() } else if day == \u0026#34;monday\u0026#34; \u0026amp;\u0026amp; isTired() { groan() } else { work() } if _, err := doThing(); err != nil { fmt.Println(\u0026#34;Uh oh\u0026#34;) ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://yohanalexander.github.io/br/notes/go/advanced/files/","summary":" Condition if day == \u0026#34;sunday\u0026#34; || day == \u0026#34;saturday\u0026#34; { rest() } else if day == \u0026#34;monday\u0026#34; \u0026amp;\u0026amp; isTired() { groan() } else { work() } if _, err := doThing(); err != nil { fmt.Println(\u0026#34;Uh oh\u0026#34;) ","tags":null,"title":"ফাইল ম্যানিপুলেশন"},{"categories":null,"contents":" Variable NAME=\u0026#34;John\u0026#34; echo $NAME echo \u0026#34;$NAME\u0026#34; echo \u0026#34;${NAME} Condition if [[ -z \u0026#34;$string\u0026#34; ]]; then echo \u0026#34;String is empty\u0026#34; elif [[ -n \u0026#34;$string\u0026#34; ]]; then echo \u0026#34;String is not empty\u0026#34; fi ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://yohanalexander.github.io/br/notes/bash/basic/","summary":" Variable NAME=\u0026#34;John\u0026#34; echo $NAME echo \u0026#34;$NAME\u0026#34; echo \u0026#34;${NAME} Condition if [[ -z \u0026#34;$string\u0026#34; ]]; then echo \u0026#34;String is empty\u0026#34; elif [[ -n \u0026#34;$string\u0026#34; ]]; then echo \u0026#34;String is not empty\u0026#34; fi ","tags":null,"title":"ব্যাশ ভেরিয়েবল"},{"categories":null,"contents":"Essa semana a chegada do Github Copilot agitou a comunidade dos desenvolvedores de software por seu funcionamento bastante impressionante apesar de ainda imperfeito, mas será que a comunidade ficou preocupada como deveria?\nMeet GitHub Copilot - your AI pair programmer. https://t.co/eWPueAXTFt pic.twitter.com/NPua5K2vFS\n— GitHub (@github) June 29, 2021 A OpenAI e o GitHub anunciaram o technical preview da IA que promete ser o seu novo pair programmer. O Copilot funciona como uma extensão as IDEs, compativível até agora com o VSCode, semelhante as ferramentas para autocomplete de código alimentada por IAs como o Tabnine, porém com diferenças fundamentais.\nComo o Copilot funciona? A ferramenta é fruto do investimento de 1 bilhão de doláres da Microsoft na OpenAI, uma empresa especializada no desenvolvimento e pesquisa de Artificial General Intelligence. \u0026ldquo;O Copilot preenche automaticamente trechos de código, sugere novas linhas e pode até mesmo escrever funções inteiras com base na descrição fornecida\u0026rdquo;, disse o CEO do Github, Nat Friedman, em um blog post.\nEm sua essência, o Copilot usa um novo algoritmo de geração de código da OpenAI chamado Codex. O CEO da OpenAI, Greg Brockman, o descreve como descendente da GPT-3, mas com foco em geração de código. O algoritmo Codex foi treinado em terabytes de código público extraído do GitHub e StackOverflow. Isso dá à ferramenta a capacidade de escrever código baseado em contexto com precisão sem precedentes.\nVocê pode se divertir com algumas sugestões de IAs para códigos filosóficos no blog post do Max Woolf.\ndef should_terminate(Person): \u0026#34;\u0026#34;\u0026#34;Check whether a Person should be terminated\u0026#34;\u0026#34;\u0026#34; if Person.id \u0026gt; 10: #terminate return True else: #continue return False A inevitabilidade da automação Mas será que as intenções da Microsoft (uma empresa multi-bilionária) são puramente benevolentes e a favor da comunidade? Por mais que uma empresa seja amiga da comunidade, o princípio do capitalismo é o lucro, e o lucro obtido ao eliminar a mão de obra especializada e bastante cara de programadores supera qualquer benefício amigável divulgado.\nA princípio você pode rejeitar a ideia de que seu emprego vai ser tomado por uma IA geradora de códigos, afinal um programador teve que criar o código da IA em primeiro lugar, certo?\nErrado. A gente tende a se prender a uma mentira confortável para ter um falso senso de segurança, mas na realidade a automação cognitiva já vem acontecendo de longa data, como é explicado neste excelente vídeo do canal CGP Grey.\nPor mais especializada que seja uma mão de obra, ela acaba sendo substituída, a automação é inevitável. Afinal, ninguém precisa de uma solução top de linha 100% do tempo, muitas vezes uma solução mediana é suficiente. Diversos exemplos semelhantes já aconteceram, e por isso, em uma era onde código pode ser gerado por IAs, a entrada no mercado de trabalho se tornará cada vez mais difícil.\nA verdade distópica O paralelo entre a inevitabilidade da automação, e o que a IA desenvolvida para o Github Copilot representam é muito bem traçada neste vídeo do canal Fireship. E após analisar o passado, fica bem mais difícil acreditar em um futuro otimista.\nPor enquanto, a ferramenta será usada para auxiliar os programadores a desempenhar sua função melhor, porém em um futuro não tão distante a IA terá aprendido e superado seus próprios criadores. Se de fato estamos \u0026ldquo;cavando nossas próprias covas\u0026rdquo; em direção a um futuro distópico para as vagas em programação, somente o tempo dirá.\nMas pelo lado bom teremos mais tempo livre \u0026#x1f604;\nLeituras complementares https://copilot.github.com/ https://github.blog/2021-06-29-introducing-github-copilot-ai-pair-programmer/ https://minimaxir.com/2021/06/gpt-j-6b/ https://thenewstack.io/github-copilot-a-powerful-controversial-autocomplete-for-developers/ https://towardsdatascience.com/should-we-be-worried-now-that-github-copilot-is-out-12f59551cd95 ","date":"July 2, 2021","hero":"/posts/github-copilot/head.png","permalink":"https://yohanalexander.github.io/br/posts/github-copilot/","summary":"Essa semana a chegada do Github Copilot agitou a comunidade dos desenvolvedores de software por seu funcionamento bastante impressionante apesar de ainda imperfeito, mas será que a comunidade ficou preocupada como deveria?\nMeet GitHub Copilot - your AI pair programmer. https://t.co/eWPueAXTFt pic.twitter.com/NPua5K2vFS\n— GitHub (@github) June 29, 2021 A OpenAI e o GitHub anunciaram o technical preview da IA que promete ser o seu novo pair programmer. O Copilot funciona como uma extensão as IDEs, compativível até agora com o VSCode, semelhante as ferramentas para autocomplete de código alimentada por IAs como o Tabnine, porém com diferenças fundamentais.","tags":["copilot","ai"],"title":"A verdade distópica sobre o Github Copilot (Programadores Não Precisam Se Candidatar)"},{"categories":null,"contents":"Todo desenvolvedor que já passou o mínimo de tempo navegando o histórico de um repositório sabe: mensagens de commits são importantes.\nMas se isso é uma verdade bem estabelecida, por que quem já tem um certo nível de experiência com versionamento de código acaba negligenciando as mensagens de commit?\nAssim como qualquer outra boa prática de programação ou versionamento de código, as mensagens de commit requerem consciência. E independente da senioriade do desenvolvedor, existem fatores que podem atrapalhar a escrita de uma boa mensagem.\nPressa a inimiga da perfeição Tem que subir pra produção ainda hoje\u0026hellip;\nPreguiça Você pode se iludir por ideias como \u0026ldquo;são apenas alterações triviais\u0026rdquo;, \u0026ldquo;mas ninguém vai ler isso depois\u0026rdquo;, \u0026ldquo;todos sabem o que estou fazendo\u0026rdquo;.\nAs mensagens devem comunicar de forma adequada o PORQUE de uma alteração ter sido feita. Entender que o histórico deve permanecer com o contexto de cada mudança ocorrida, faz a colaboração e o desenvolvimento mais eficientes.\nFalta de atomicidade Sabe quando você se atrapalha muito na hora de escrever uma mensagem porque nada descreve o contexto completo da mudança?\nCommits que englobam muitas mudanças são uma prática ruim de versionamento, e a própria confusão ao criar uma mensagem já indica isso. A lógica das alterações devem ser divididas em átomos, unidades bem simples que implementam uma única funcionalidade ou corrigem um erro específico. E os commits são uma instância dessas alterações, uma representação simplificada do que a lógica completa representa.\nEm posts futuros falarei sobre como usar a ferramenta do GIT de forma eficiente e a seu favor, exemplificando quando, onde e como commitar.\nImprudência Você já sabe que é importante, tem a expertise da ferramenta, e ainda assim decide fazer errado. shame on you\nPor que escrever uma excelente mensagem de commit? Mas se ainda assim você não se sentiu convencido do porque escrever uma excelente mensagem de commit, vamos recriar um cenário comum na carreira dos desenvolvedores.\nVocê recebe do seu PO uma demanda de prioridade média com a task \u0026ldquo;corrigir erro no cadastro de usuários\u0026rdquo;. Determinado a resolver o problema de forma eficiente, você navega pelo repositório para encontrar o bug no escopo do cadastro. Para a sua surpresa, os métodos não tem documentação, nem testes, e você não entende absolutamente nada pelo diff dos arquivos modificados. O git blame aponta que o último commit foi feito há 1 mês às 01:37 da manhã de uma sexta-feira com a mensagem \u0026ldquo;pequenas alterações\u0026rdquo;. Após respirar fundo por ter a sua paz interior brevemente abalada, você checa o git log para entender os commits anteriores, e se depara com mensagens bastante explicativas como \u0026ldquo;consertando bug\u0026rdquo;, \u0026ldquo;adicionando método\u0026rdquo;, \u0026ldquo;fazendo alterações no método\u0026rdquo;, \u0026ldquo;melhorando correções\u0026rdquo;, e etc.\nUma mensagem de commit bem pensada é a melhor maneira de comunicar o contexto de uma mudança, seja para outros desenvolvedores, ou até para você mesmo no futuro.\nMas como se tornar um artesão de mensagens de commit? Antes de tudo é preciso entender que mensagens de commit excelentes não surgem por acaso. Você nunca irá se deparar com um histórico de mensagens impecável, onde os colaboradores não tiveram o cuidado necessário com cada um dos commits. Excelência é fruto de boas práticas aplicadas no dia a dia.\nE para guiar nossas práticas, existem as convenções e padronizações (cada time deve entrar em acordo do que melhor se adequa a sua realidade).\nO Conventional Commits O Conventional Commits -ou commits semânticos- é uma convenção de mensagens de commit, para ajudar a manter um histórico de commits explícito e bem estruturado. Ao seguir esse tipo de convenção, podemos automatizar a criação de CHANGELOGs, facilitar a entrada de novos desenvolvedores no projeto, além de conseguir entender onde está se concentrando as horas do projeto (em refatoração de código, criação de features, ou fix de bugs).\nPara quem ainda não conhece, esse é o formato padrão de um commit semântico:\n[tipo](escopo opcional): [assunto] [corpo opcional] [rodapé opcional] Um exemplo prático:\nfix(containers/profile): adjust argument of getThumbnailImage function getThumbnailImage used to receive argument of type XPTO. Now receives the correct argument of type FOO. Solves issue #132 Tipos de commits O tipo de um commit é a descrição inicial do que o commit está realizando e são uma lista bem definida:\ntest: indica qualquer tipo de criação ou alteração de códigos de teste. Exemplo: Criação de testes unitários. feat: indica o desenvolvimento de uma nova feature ao projeto. Exemplo: Acréscimo de um serviço, funcionalidade, endpoint, etc. refactor: usado quando houver uma refatoração de código que não tenha qualquer tipo de impacto na lógica ou regras de negócio do sistema. Exemplo: Mudanças de código após um code review. style: empregado quando há mudanças de formatação e estilo do código que não alteram o sistema de nenhuma forma. Exemplo: Mudar o style-guide, arrumar indentações, remover espaços em brancos, remover comentários, etc. fix: utilizado quando há correção de erros que estão gerando bugs no sistema. Exemplo: Aplicar tratativa para uma função que não está tendo o comportamento esperado e retornando erro. chore: indica mudanças no projeto que não afetem o sistema ou arquivos de testes. Exemplo: Mudar variáveis de ambiente em arquivos .env, adicionar mais extensões de arquivos ao .gitignore. docs: usado quando há mudanças na documentação do projeto. Exemplo: adicionar informações na documentação da API, mudar o README, etc. build: utilizada para indicar mudanças que afetam o processo de build do projeto ou dependências externas. Exemplo: adicionar ou remover dependências do requirements do projeto, etc. perf: indica uma alteração que melhorou a performance do sistema. Exemplo: alterar ForEach por while, melhorar a query ao banco, etc. ci: utilizada para mudanças nos arquivos de configuração de CI. Exemplo: Circle, Travis, BrowserStack, etc. revert: indica a reversão de um commit anterior. Escopos de commits O escopo do commit é uma parte opcional, curta e de fácil compreensão. É nela que iremos indicar qual parte do código foi modificada, como a camada de um microsserviço por exemplo. Em geral, a utilização do escopo é bem genérica, podendo por exemplo associar a numeração de tasks caso sua equipe siga alguma metodologia ágil.\nCorpos de commits O corpo, por sua vez, vai conter descrições mais precisas do que está contido naquele commit, mostrando as razões ou consequências geradas por esse código.\nRodapés de commits O rodapé restringe-se às alterações de estado, como resoluções do estado de issues ou associação de uma task. Exemplo: \u0026ldquo;resolves issue #312\u0026rdquo;.\nAssuntos de commits O assunto -ou mensagem- é obrigatório, e por isso é a parte mais importante do padrão, e deve ser suficientemente clara sobre o porque das alterações no commit. Lembre que o diff das alterações te diz o que mudou, mas somente a mensagem representa de forma eficiente o PORQUE das alterações.\nNo artigo de Chris Beams são definidas também 7 regras para uma boa mensagem:\nSepare o assunto do corpo com uma linha em branco Limite a linha de assunto a 50 caracteres Coloque a linha de assunto em maiúscula Não termine a linha de assunto com um ponto Use o modo imperativo na linha de assunto Envolva o corpo em até 72 caracteres Use o corpo para explicar o quê e por quê vs. como Não vou me aprofundar em cada regra, pois a maioria já é auto explicativa. Mas para alguns, a regra 5, sobre escrever a mensagem no imperativo gera um leve estranhamento inicial, pois a mudança implementada foi uma \u0026ldquo;ação passada\u0026rdquo;, mas ao escrever mensagens utilizando o modo imperativo nós estamos dizendo o que o commit faz se aplicado.\nSe você fosse fizer um cherry-pick (copiar um commit de uma brancha pra outra) ou um revert por exemplo, aquele commit vai \u0026ldquo;realizar uma tarefa\u0026rdquo; não vai \u0026ldquo;realizou uma tarefa\u0026rdquo;.\nA regra de ouro é que a mensagem deve completar a frase:\nSe aplicado, esse commit vai mensagem de commit aqui\ngit commit -m \u0026#34;\u0026lt;mensagem de commit aqui\u0026gt;\u0026#34; Por fim, veja o exemplo real de um commit feito para o repositório core do Bitcoin:\ncommit eb0b56b19017ab5c16c745e6da39c53126924ed6 Author: Pieter Wuille \u0026lt;pieter.wuille@gmail.com\u0026gt; Date: Fri Aug 1 22:57:55 2014 +0200 Simplify serialize.h\u0026#39;s exception handling Remove the \u0026#39;state\u0026#39; and \u0026#39;exceptmask\u0026#39; from serialize.h\u0026#39;s stream implementations, as well as related methods. As exceptmask always included \u0026#39;failbit\u0026#39;, and setstate was always called with bits = failbit, all it did was immediately raise an exception. Get rid of those variables, and replace the setstate with direct exception throwing (which also removes some dead code). As a result, good() is never reached after a failure (there are only 2 calls, one of which is in tests), and can just be replaced by !eof(). fail(), clear(n) and exceptions() are just never called. Delete them. Leituras complementares How to Write a Git Commit Message On Commit Messages A Note About Git Commit Messages Commit Guidelines Keep Your Commits \u0026ldquo;Atomic\u0026rdquo; Conventional Commits Keep a Changelog ","date":"April 30, 2021","hero":"/posts/commit-messages/git-commit.png","permalink":"https://yohanalexander.github.io/br/posts/commit-messages/","summary":"Todo desenvolvedor que já passou o mínimo de tempo navegando o histórico de um repositório sabe: mensagens de commits são importantes.\nMas se isso é uma verdade bem estabelecida, por que quem já tem um certo nível de experiência com versionamento de código acaba negligenciando as mensagens de commit?\nAssim como qualquer outra boa prática de programação ou versionamento de código, as mensagens de commit requerem consciência. E independente da senioriade do desenvolvedor, existem fatores que podem atrapalhar a escrita de uma boa mensagem.","tags":["git"],"title":"Mensagens de commit são subestimadas (e não deveriam)"},{"categories":null,"contents":"Bem vindo ao meu blog!\nNo final do ano de 2020 e dessa situção bizarra que o mundo passou a enfrentar decidi começar a escrever um blog.\nA ideia é compartilhar qualquer conhecimento interessante sobre tecnologia que descobri enquanto trabalho em vários projetos.\nAs postagens sobre ferramentas e tecnologias novas provavelmente serão mais curtas para manter as coisas direto ao ponto, e em um formato parecido com tutoriais, para indicar ao leitor o caminho para obter os mesmos resultados que obtive.\nEventualmente falarei também de forma mais aberta sobre assuntos mais teóricos, como boas práticas de programação e os desafios na construção de softwares escaláveis, além de segurança da informação e ciência de dados.\nEm um próximo post falarei sobre como construí toda a infraestrutura de disponibilização desse blog, para que a escrita seja minimalista e bastante simples.\n","date":"January 18, 2021","hero":"/posts/hello-world/hello.png","permalink":"https://yohanalexander.github.io/br/posts/hello-world/","summary":"Bem vindo ao meu blog!\nNo final do ano de 2020 e dessa situção bizarra que o mundo passou a enfrentar decidi começar a escrever um blog.\nA ideia é compartilhar qualquer conhecimento interessante sobre tecnologia que descobri enquanto trabalho em vários projetos.\nAs postagens sobre ferramentas e tecnologias novas provavelmente serão mais curtas para manter as coisas direto ao ponto, e em um formato parecido com tutoriais, para indicar ao leitor o caminho para obter os mesmos resultados que obtive.","tags":null,"title":"Bem vindo ao meu blog!"}]